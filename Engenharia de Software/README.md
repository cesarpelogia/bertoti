# Atividade 1:

Withain Google, we sometimes say, “Software engineering is programming integrated over time.” Programming is certainly a significant part of software : engineering after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomesnsion to programming. Cubes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, mmimaintenance). The addition of time adds an important new dimeension to programming.

We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth.

Engenharia de software é uma área da programação que atua no desenvolvimento, manutenção e modificação de sistemas computacionais. Tal área se difere do desenvolvimento clássico por 3 pontos: tempo, escala e trade-offs

- Tempo: Na engenharia de software, o tempo é crítico para cumprir prazos, atender às expectativas do cliente e garantir a competitividade. A metodologia ágil auxilia no melhor desenvolvimento.

- Escala: Escala refere-se ao tamanho que sistema a ser desenvolvido pode atender. Gerenciar a escala envolve escolher arquiteturas apropriadas para garantir que o sistema possa crescer e se adaptar às demandas futuras.
  
- Trade-offs: A engenharia de software envolve trade-offs, onde otimizar um aspecto pode resultar em compromissos em outros. Decisões são tomadas visando desempenho versus consumo de recursos ou velocidade de desenvolvimento versus qualidade do código exigem equilíbrio e compreensão das prioridades do projeto.

----------------------------------------------------

# Atividade 2:

## 3 Exemplos de Trade-offs de Software:

# PyCharm / VSCode

### Versatilidade:

- PyCharm:
O PyCharm é uma IDE dedicada a linguagem Python, e por essa razão, oferece uma ampla gama de recurso específicos, o tornando mais atrativo para usuários dessa linguagem. Em contrapartida ela não oferece suporte para outras linguagens de forma nativa.

- VSCode:
A ampla gama de linguagens que a interface que a IDE reconhece de forma nativa e a ampla quantidade de extensões disponíveis no mercado, combinada com a facilidade de criação de extensões personalizadas, tornam o VSCode uma escolha flexível para projetos em diferentes linguagens.

### Utilização:

- PyCharm:
Devivo ao fato do PyCharn ser um software que necessita de pagamento de licença, isso dificulta seu acesso. Essa questão impossibilita do software ser mais popular, porém o fato de existir uma empresa controlando, o suporte e a robustês da IDE ser maior.

- VSCode:
O VSCode é uma IDE de código aberto e por isso, gratúita. Esse fato aproxima usuários inciantes e estudantes, sendo a porta de entrada para muitos novos usuários. Soma-se a isso, a grande possibilidade de personização faz do VSCode uma opção mais atrativa para usuários exporádicos.

### Consumo de memória:

- PyCharm:

PyCharm, uma IDE robusta para Python, consome muita memória devido a funcionalidades avançadas como análise de código e autocompletar. Isso pode afetar o desempenho do sistema, especialmente em máquinas com recursos limitados.

- VSCode:

VS Code é uma IDE leve e eficiente, mas seu consumo de memória pode aumentar ao usar extensões e funcionalidades avançadas. Embora geralmente consuma menos memória que IDEs mais robustas, o uso intensivo de plugins e a execução de várias tarefas podem impactar o desempenho em sistemas com recursos limitados.




-----------------------------------------------------

# Java / Python

### Sintaxe:

- Java:

Java é conhecido por sua sintaxe mais verbosa e estruturada. Cada declaração precisa ser explicitamente escrita, o que pode resultar em mais linhas de código para realizar a mesma tarefa que em Python.

- Python:

Uma das características mais notáveis do Python é sua sintaxe simples e fácil de entender. Com uma sintaxe clara e legível, o Python permite que os programadores escrevam códigos de forma concisa e expressiva.

### Tipagem:

- Java:

Java é uma linguagem de tipagem estática, o que significa que os tipos de todas as variáveis devem ser definidos em tempo de compilação. Isso ajuda a evitar erros de tipo antes de executar o código.

- Python:

Python é uma linguagem de tipagem dinâmica, o que significa que você não precisa declarar explicitamente o tipo de uma variável. O tipo é determinado em tempo de execução.

### Desempenho:

- Java:

Java é uma linguagem compilada para bytecode (código intermediário gerado após a compilação do código-fonte Java) pela JVM (Java Virtual Machine), que utiliza a compilação Just-In-Time (JIT) para converter bytecode em código de máquina nativo durante a execução, permitindo otimização de tempo de compilação e melhor desempenho em comparação com linguagens interpretadas.Java também oferece suporte robusto para multithreading, aproveitando múltiplos núcleos de CPU de forma eficiente.

- Python:

Python é uma linguagem interpretada com tipagem dinâmica, resultando em uma execução mais lenta. O Global Interpreter Lock (GIL) em CPython impede a execução simultânea de múltiplas threads, limitando o desempenho em aplicações multithreaded. 


-------------------------------------------------------

## Windows / Linux

### Segurança:

- Windows:

Windows é um alvo mais comum para ataques de malware e vírus devido à sua popularidade. Um fato que potencializa essa vunerabilidade são as atualizações de segurança da Microsoft, que por vezes, são menos eficientes que as fornecidas pelas concorrentes.

- Linux

O fato de sistemas operacionais com kernel linux serem mais complexos para serem invadidos é sua alta possibilidade de personalização, além do fato de receber atualizações de segurança com maior frequência em relação ao windows.

### Utilização:

- Windows

Apesar de ser pago, o Windows é o sistema opreacional mais popular do mercado. Devido a esse fato, a maioria das pessoas que tem acesso a um computador, provavelmente teve contato com um sistema operacional Windows, da Microsoft. Essa popuplaridade também corrobora para a maior dispinibilidade de softwares, o tornando uma excelente escolha para empresas que precisam de computadores para diversas funções e que tem a possibilidade de funcionários com menor conhecimento de informática. 

- Linux

Sistemas operacionais que utilizam um kernel linux são de código aberto, ou seja, não necessitam de pagamento. Porém, isso não é suficiente para que seu alcance se iguale ao concorrente da Microsoft. Embora menos popular, esse sistema operacional é altamente usado por empresas em servidores, devido a sua ampla capacidade de personalização.

### Suporte

- Windows

Devido ao fato da empresa dona do Windows ser a lider de mercado, seu suporte é bem extruturado e possui grande suporte direto, fornecido pela propria empresa, ou indireto, fornecido por técnicos independentes. O suporte da empresa é feito por especialistas com grande experiência e acesso a muitos recursos.

- Linux

Sistemas operacionais de código aberto como o linux não possuem uma empresa por trás, que tenha uma gama de recursos para prover ao usuário. Apesar da grande comunidade de usuários que alimentam a internet com informações, a quantidade de mão de obra é inferior e nem sempre tão especilazada como da Microsoft.

--------------------------------------------------

# Atividade 3:

https://docs.google.com/presentation/d/1Lmad2CS1pM1UycQpYn6FiDm2NsEO6CVSchym65tuk4U/edit?pli=1#slide=id.g1f2b4e971a0_0_179

Slide:

### 24 - Estilo de Arquitetura em Camadas:

 - Positivo: Custo.
   
     A simplicidade inerente ao estilo de arquitetura em camadas reduz significativamente o custo de construção do projeto. A clara separação de responsabilidades entre as diferentes camadas facilita tanto o desenvolvimento quanto a manutenção do sistema. Essa divisão modular permite que desenvolvedores trabalhem em componentes específicos sem interferir nos outros, acelerando o processo de desenvolvimento e diminuindo a complexidade.

     Além disso, essa arquitetura facilita a construção de testes, pois cada camada pode ser testada de maneira independente. Isso resulta em uma detecção mais rápida de bugs e problemas, contribuindo para uma manutenção mais eficiente e menos onerosa ao longo do ciclo de vida do software.

 - Negativo: Escalabilidade
   
     Apesar das vantagens de custo, a simplicidade do estilo de arquitetura em camadas pode ser prejudicial em termos de escalabilidade. Cada camada adiciona uma quantidade significativa de processamento e comunicação de dados, o que pode sobrecarregar o sistema e impactar a performance, especialmente em sistemas de grande escala.

     Quando um sistema cresce e precisa processar um volume maior de dados, a arquitetura em camadas pode se tornar um gargalo. A necessidade de maior desempenho pode levar ao aumento dos recursos de hardware, o que contraria a vantagem de custo inicialmente mencionada. Esse aumento na necessidade de hardware e processamento pode tornar a escalabilidade vertical (aumento de capacidade do servidor) limitada e cara.

 - Aplicação:

     A arquitetura em camadas é adequada para sistemas de pequeno porte, como os de um pequeno comércio. Nesses casos, o número de itens e transações é limitado, não exigindo uma grande capacidade de processamento e permitindo que a simplicidade e a facilidade de manutenção superem os desafios de escalabilidade.


### 25 - Estilo de Arquitetura de Pipeline

 - Positivo: Simplicidade

  A arquitetura de pipeline é conhecida por sua simplicidade e clareza na organização do fluxo de dados. Cada etapa do pipeline tem uma função específica e bem definida, o que facilita o desenvolvimento e a manutenção do sistema. Essa modularidade permite que cada componente do pipeline seja desenvolvido, testado e depurado de maneira independente, simplificando o gerenciamento e a integração do sistema como um todo.

  Além disso, a natureza sequencial do pipeline torna mais fácil entender e seguir o fluxo de processamento dos dados.  Novos desenvolvedores podem rapidamente se familiarizar com o sistema, pois cada etapa é um bloco de construção lógico e isolado. Isso resulta em um ciclo de desenvolvimento mais ágil e uma curva de aprendizado menor.

 - Negativo: Elasticidade

  Por outro lado, a arquitetura de pipeline pode enfrentar desafios em termos de elasticidade, especialmente quando há variações significativas na carga de trabalho. Cada estágio do pipeline pode se tornar um ponto de gargalo, e a necessidade de balancear a carga entre as etapas pode complicar a escalabilidade.

  A elasticidade refere-se à capacidade do sistema de se ajustar dinamicamente à carga de trabalho. Em um pipeline, se uma etapa específica enfrenta uma sobrecarga, ela pode atrasar o processamento de todo o fluxo, pois as etapas são dependentes umas das outras. Gerenciar essa elasticidade requer uma coordenação cuidadosa e, muitas vezes, soluções adicionais de balanceamento de carga e paralelização, o que pode aumentar a complexidade e o custo operacional.

  - Aplicação:

  A arquitetura de pipeline é adequada para sistemas que realizam operações sequenciais de processamento de dados, como um sistema de cadastro de usuários. Neste exemplo, as etapas podem incluir a validação dos dados de entrada, a formatação das informações, a verificação de duplicatas, e a inserção dos dados no banco de dados. Cada etapa processa os dados e os passa para a próxima, garantindo um fluxo organizado e eficiente.


### 26 - Microkernel Architecture Style

 - Positivo: Simplicidade.

  A arquitetura microkernel é valorizada por sua simplicidade estrutural e modularidade. No núcleo (kernel) do sistema reside apenas a funcionalidade essencial e mínima necessária para operar. Funcionalidades adicionais e extensões são implementadas como plug-ins ou módulos externos que interagem com o kernel.

  Essa separação clara entre o núcleo básico e os módulos permite um desenvolvimento e uma manutenção mais simples e flexível. Cada módulo ou plug-in pode ser desenvolvido, atualizado, e mantido independentemente do núcleo e dos outros módulos. Isso facilita a adição de novas funcionalidades sem a necessidade de alterar a base do sistema, promovendo uma rápida evolução e adaptabilidade do software.

 - Negativo: Tolerância a falhas.

  Uma das principais desvantagens da arquitetura microkernel é a sua tolerância a falhas. Como o núcleo do sistema é responsável pela coordenação e comunicação entre todos os módulos, qualquer falha ou erro no kernel pode comprometer todo o sistema. Além disso, a dependência de múltiplos módulos pode introduzir complexidade na gestão de falhas, pois uma falha em um módulo pode potencialmente afetar outros módulos ou o próprio kernel.

  A integração e a intercomunicação entre os módulos e o kernel precisam ser cuidadosamente gerenciadas para evitar que falhas isoladas se propaguem pelo sistema. Isso pode requerer estratégias adicionais de isolamento de falhas e recuperação, aumentando a complexidade do sistema.

 - Aplicação:

  Uma das principais desvantagens da arquitetura microkernel é a sua tolerância a falhas. Como o núcleo do sistema é responsável pela coordenação e comunicação entre todos os módulos, qualquer falha ou erro no kernel pode comprometer todo o sistema. Além disso, a dependência de múltiplos módulos pode introduzir complexidade na gestão de falhas, pois uma falha em um módulo pode potencialmente afetar outros módulos ou o próprio kernel.

  A integração e a intercomunicação entre os módulos e o kernel precisam ser cuidadosamente gerenciadas para evitar que falhas isoladas se propaguem pelo sistema. Isso pode requerer estratégias adicionais de isolamento de falhas e recuperação, aumentando a complexidade do sistema.


### 27 - Service-Based Architecture Style

 - Positivo: Tolerância a falhas

  A arquitetura baseada em serviços é altamente tolerante a falhas devido à sua estrutura modular e independente. Cada serviço opera de forma autônoma, com responsabilidades bem definidas, permitindo que o sistema continue funcionando mesmo se um serviço específico falhar. Por exemplo, em um site de vendas, se o serviço de processamento de pedidos tiver problemas, o serviço de exibição de produtos e o carrinho de compras ainda podem operar normalmente, minimizando o impacto negativo sobre a experiência do usuário.

  Essa independência dos serviços aumenta a resiliência geral do sistema, já que as falhas podem ser isoladas e tratadas sem comprometer a totalidade da aplicação. Além disso, facilita a implementação de estratégias de recuperação de falhas, como reinicialização automática de serviços ou rerouting de solicitações para instâncias saudáveis
  
 - Negativo: Elasticidade

  No entanto, a arquitetura baseada em serviços pode enfrentar desafios significativos em termos de elasticidade. Elasticidade refere-se à capacidade do sistema de ajustar dinamicamente os recursos para atender às demandas variáveis. Na arquitetura baseada em serviços, cada serviço deve ser escalado de forma independente, o que pode ser complicado e exigir um gerenciamento sofisticado.

  A comunicação entre serviços geralmente ocorre através de redes, o que pode introduzir latência e complexidade adicional. Coordenar a escalabilidade dos serviços para que eles funcionem harmoniosamente pode ser difícil, especialmente se alguns serviços demandarem mais recursos que outros em momentos específicos. Esse desafio pode resultar em custos operacionais mais altos e exigir ferramentas avançadas de monitoramento e orquestração para gerenciar eficientemente a elasticidade do sistema.

  - Aplicação:

  Ideal para site de vendas, com catálogo de produtos, processamento de pedidos, carrinhos de vendas pois se uma parte do sistema falha, o restante continua funcionando.

### 28 - Event-Driven Architecture Style

 - Positivo: Escalabilidade

  A arquitetura orientada a eventos (Event-Driven Architecture) é altamente escalável devido à sua capacidade de processar eventos de forma assíncrona e distribuída. Nesse estilo arquitetônico, os componentes do sistema se comunicam através da emissão e consumo de eventos, permitindo um desacoplamento significativo entre os produtores e consumidores de eventos. Isso facilita a escalabilidade horizontal, pois novos consumidores podem ser adicionados conforme necessário para lidar com aumentos na carga de trabalho.

  Além disso, a capacidade de processar eventos em paralelo e distribuir a carga de trabalho entre múltiplas instâncias contribui para a alta escalabilidade. Esse modelo é particularmente útil em sistemas que exigem respostas rápidas e processamento de grandes volumes de dados em tempo real, como um sistema de logística e vendas que precisa integrar múltiplos subsistemas, como inventário, entrega e processamento de pedidos.

 - Negativo: Simplicidade

  Apesar de suas vantagens em termos de escalabilidade, a arquitetura orientada a eventos pode ser complexa de implementar e manter. A natureza assíncrona e distribuída dos eventos pode introduzir desafios significativos de coordenação, depuração e monitoramento. Garantir a consistência dos dados e a ordem correta dos eventos pode ser complicado, especialmente em sistemas distribuídos onde a latência de rede e as falhas de comunicação são comuns.

  Além disso, a necessidade de gerenciar estados e eventos de forma robusta requer um planejamento cuidadoso e a implementação de mecanismos de recuperação de falhas, persistência de eventos e reprocessamento. Essa complexidade pode aumentar o tempo de desenvolvimento e os custos operacionais, exigindo uma equipe com habilidades especializadas em sistemas distribuídos e processamento assíncrono.

  - Aplicação:

  Poderia ser usado em um sistema de logística e vendas, visando integração de vários sistemas.

### 29  Microservices Architecture

 - Positivo: Escalabilidade

  A arquitetura de microservices é altamente escalável devido à sua abordagem modular e descentralizada. Cada microservice é um componente independente que pode ser desenvolvido, implantado e escalado de forma autônoma. Isso permite que diferentes partes do sistema cresçam de acordo com suas necessidades específicas de carga e desempenho.

  Por exemplo, em uma plataforma de streaming, serviços como gerenciamento de usuários, catálogo de conteúdo, recomendação de vídeos, e streaming de vídeo podem ser escalados individualmente. Se o serviço de streaming de vídeo enfrentar alta demanda, ele pode ser escalado horizontalmente (adicionando mais instâncias) sem impactar outros serviços. Essa capacidade de escalar componentes de forma independente melhora a eficiência e a resiliência do sistema, garantindo que ele possa suportar picos de tráfego e crescimento contínuo.

 - Negativo: Simplicidade

  Apesar de suas vantagens em escalabilidade, a arquitetura de microservices pode ser complexa de implementar e gerenciar. A decomposição de uma aplicação monolítica em vários microservices aumenta a quantidade de componentes que precisam ser coordenados. Cada microservice tem seu próprio ciclo de vida, armazenamento de dados, e comunicação, o que pode introduzir complexidade na gestão de dependências, latência de rede, e consistência de dados.

  Além disso, implementar uma comunicação eficiente e segura entre microservices, lidar com falhas de rede, e garantir a observabilidade (monitoramento, logging, e tracing) são desafios significativos. A necessidade de ferramentas e práticas robustas para orquestração, como Kubernetes, bem como uma equipe com habilidades especializadas em sistemas distribuídos, pode aumentar a complexidade e os custos operacionais.

  - Aplicação:
  
  A arquitetura de microservices é ideal para uma plataforma de streaming, onde diferentes funcionalidades podem ser implementadas como serviços independentes, tais como: serviço de autenticação, serviço de catálogo de conteúdo, seriço de análise, entre outros.

  

# Atividade 4

### Defina sua arquitetura debatendo tradeoffs com os requisitos não funcionais comentados em aula

Sistema escolhido: "Layered Architecture Style"

  Sistema escolhido devivo a simplicidade e ao baixo custo. Sistema será usado em uma pequena mercearia.

# Atividade 5

### Inicie seu diagrama de classes de uma das partes da arquitetura (escolha uma parte de backend por favor)

<p align="center">
  <img src="Classe UML.png" alt="Diagrama de Classes">
</p>

# Atividade 8:

## Diagrama de Casos de Uso.

<p align="center">
  <img src="Diagrama de caso de uso.png" alt="Diagrama de Casos de Uso">
</p>
